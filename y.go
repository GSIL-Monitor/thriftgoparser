// Code generated by goyacc - DO NOT EDIT.

package main

import __yyfmt__ "fmt"

import (
	"fmt"
	"github.com/AfLnk/thriftgoparser/proto"
)

/**
 * This global variable is used for automatic numbering of field indices etc.
 * when parsing the members of a struct. Field values are automatically
 * assigned starting from -1 and working their way down.
 */
var y_field_val = -1

/**
 * This global variable is used for automatic numbering of enum values.
 * y_enum_val is the last value assigned; the next auto-assigned value will be
 * y_enum_val+1, and then it continues working upwards.  Explicitly specified
 * enum values reset y_enum_val to that value.
 */
var y_enum_val int64 = -1
var G_arglist = 0
var struct_is_struct int64 = 0
var struct_is_union int64 = 1
var g_strict = 255

var SHRT_MIN int = 0
var SHRT_MAX int = 2147483647

type yySymType struct {
	yys        int
	id         string
	iconst     int64
	dconst     float64
	bconst     bool
	tbool      bool
	tdoc       *proto.TDoc
	caftype    proto.ICafType
	tbase      *proto.TBaseType
	ttypedef   *proto.TTypedef
	tenum      *proto.TEnum
	tenumv     *proto.TEnumValue
	tconst     *proto.TConst
	tconstv    *proto.TConstValue
	tstruct    *proto.TStruct
	tservice   *proto.TService
	tfunction  *proto.TFunction
	tcontainer *proto.TContainer
	tlist      *proto.TList
	tmap       *proto.TMap
	tset       *proto.TSet
	tfield     *proto.TField
	dtext      string
	ereq       int32 // TField:EReq
	tannot     *proto.TAnnotation
	tfieldid   *proto.TFieldId
}

type yyXError struct {
	state, xsym int
}

const (
	yyDefault         = 57387
	yyEofCode         = 57344
	yyErrCode         = 57345
	tok_binary        = 57363
	tok_bool          = 57361
	tok_bool_constant = 57351
	tok_const         = 57382
	tok_cpp_include   = 57354
	tok_cpp_type      = 57355
	tok_doctext       = 57348
	tok_double        = 57370
	tok_dub_constant  = 57350
	tok_enum          = 57381
	tok_extends       = 57379
	tok_i16           = 57367
	tok_i32           = 57368
	tok_i64           = 57369
	tok_i8            = 57366
	tok_identifier    = 57346
	tok_include       = 57352
	tok_int_constant  = 57349
	tok_list          = 57372
	tok_literal       = 57347
	tok_map           = 57371
	tok_namespace     = 57353
	tok_oneway        = 57374
	tok_optional      = 57384
	tok_reference     = 57386
	tok_required      = 57383
	tok_senum         = 57365
	tok_service       = 57380
	tok_set           = 57373
	tok_slist         = 57364
	tok_string        = 57362
	tok_struct        = 57376
	tok_throws        = 57378
	tok_typedef       = 57375
	tok_union         = 57385
	tok_void          = 57360
	tok_xception      = 57377
	tok_xsd_all       = 57356
	tok_xsd_attrs     = 57359
	tok_xsd_nillable  = 57358
	tok_xsd_optional  = 57357

	yyMaxDepth = 200
	yyTabOfs   = -115
)

var (
	yyPrec = map[int]int{}

	yyXLAT = map[int]int{
		57346: 0,   // tok_identifier (127x)
		44:    1,   // ',' (61x)
		57363: 2,   // tok_binary (57x)
		57361: 3,   // tok_bool (57x)
		57370: 4,   // tok_double (57x)
		57367: 5,   // tok_i16 (57x)
		57368: 6,   // tok_i32 (57x)
		57369: 7,   // tok_i64 (57x)
		57366: 8,   // tok_i8 (57x)
		57372: 9,   // tok_list (57x)
		57371: 10,  // tok_map (57x)
		57373: 11,  // tok_set (57x)
		57364: 12,  // tok_slist (57x)
		57362: 13,  // tok_string (57x)
		125:   14,  // '}' (56x)
		40:    15,  // '(' (51x)
		57344: 16,  // $end (46x)
		57382: 17,  // tok_const (46x)
		57381: 18,  // tok_enum (46x)
		57349: 19,  // tok_int_constant (46x)
		57365: 20,  // tok_senum (46x)
		57380: 21,  // tok_service (46x)
		57376: 22,  // tok_struct (46x)
		57375: 23,  // tok_typedef (46x)
		57385: 24,  // tok_union (46x)
		57377: 25,  // tok_xception (46x)
		59:    26,  // ';' (36x)
		57384: 27,  // tok_optional (36x)
		57383: 28,  // tok_required (36x)
		41:    29,  // ')' (34x)
		123:   30,  // '{' (31x)
		57347: 31,  // tok_literal (30x)
		62:    32,  // '>' (28x)
		57386: 33,  // tok_reference (26x)
		91:    34,  // '[' (21x)
		57350: 35,  // tok_dub_constant (21x)
		57360: 36,  // tok_void (15x)
		57359: 37,  // tok_xsd_attrs (15x)
		93:    38,  // ']' (14x)
		57374: 39,  // tok_oneway (13x)
		57358: 40,  // tok_xsd_nillable (13x)
		57438: 41,  // TypeAnnotations (12x)
		57354: 42,  // tok_cpp_include (11x)
		57352: 43,  // tok_include (11x)
		57353: 44,  // tok_namespace (11x)
		57357: 45,  // tok_xsd_optional (11x)
		58:    46,  // ':' (10x)
		57390: 47,  // CommaOrSemicolonOptional (9x)
		57388: 48,  // BaseType (8x)
		57389: 49,  // CaptureDocText (8x)
		57397: 50,  // ContainerType (8x)
		57412: 51,  // FieldType (8x)
		57421: 52,  // ListType (8x)
		57422: 53,  // MapType (8x)
		57429: 54,  // SetType (8x)
		57430: 55,  // SimpleBaseType (8x)
		57431: 56,  // SimpleContainerType (8x)
		60:    57,  // '<' (6x)
		57392: 58,  // ConstList (5x)
		57394: 59,  // ConstMap (5x)
		57396: 60,  // ConstValue (5x)
		57407: 61,  // Field (5x)
		57409: 62,  // FieldList (5x)
		61:    63,  // '=' (4x)
		57398: 64,  // CppType (3x)
		57355: 65,  // tok_cpp_type (3x)
		42:    66,  // '*' (1x)
		57391: 67,  // Const (1x)
		57393: 68,  // ConstListContents (1x)
		57395: 69,  // ConstMapContents (1x)
		57399: 70,  // Definition (1x)
		57400: 71,  // DefinitionList (1x)
		57401: 72,  // DestroyDocText (1x)
		57402: 73,  // Enum (1x)
		57403: 74,  // EnumDef (1x)
		57404: 75,  // EnumDefList (1x)
		57405: 76,  // EnumValue (1x)
		57406: 77,  // Extends (1x)
		57408: 78,  // FieldIdentifier (1x)
		57410: 79,  // FieldReference (1x)
		57411: 80,  // FieldRequiredness (1x)
		57413: 81,  // FieldValue (1x)
		57414: 82,  // FlagArgs (1x)
		57415: 83,  // Function (1x)
		57416: 84,  // FunctionList (1x)
		57417: 85,  // FunctionType (1x)
		57418: 86,  // Header (1x)
		57419: 87,  // HeaderList (1x)
		57420: 88,  // Include (1x)
		57423: 89,  // Oneway (1x)
		57424: 90,  // Program (1x)
		57425: 91,  // Senum (1x)
		57426: 92,  // SenumDef (1x)
		57427: 93,  // SenumDefList (1x)
		57428: 94,  // Service (1x)
		57432: 95,  // Struct (1x)
		57433: 96,  // StructHead (1x)
		57434: 97,  // Throws (1x)
		57379: 98,  // tok_extends (1x)
		57378: 99,  // tok_throws (1x)
		57356: 100, // tok_xsd_all (1x)
		57435: 101, // TypeAnnotation (1x)
		57436: 102, // TypeAnnotationList (1x)
		57437: 103, // TypeAnnotationValue (1x)
		57440: 104, // Typedef (1x)
		57439: 105, // TypeDefinition (1x)
		57441: 106, // UnflagArgs (1x)
		57442: 107, // Xception (1x)
		57443: 108, // XsdAll (1x)
		57444: 109, // XsdAttributes (1x)
		57445: 110, // XsdNillable (1x)
		57446: 111, // XsdOptional (1x)
		57387: 112, // $default (0x)
		57345: 113, // error (0x)
		57351: 114, // tok_bool_constant (0x)
		57348: 115, // tok_doctext (0x)
	}

	yySymNames = []string{
		"tok_identifier",
		"','",
		"tok_binary",
		"tok_bool",
		"tok_double",
		"tok_i16",
		"tok_i32",
		"tok_i64",
		"tok_i8",
		"tok_list",
		"tok_map",
		"tok_set",
		"tok_slist",
		"tok_string",
		"'}'",
		"'('",
		"$end",
		"tok_const",
		"tok_enum",
		"tok_int_constant",
		"tok_senum",
		"tok_service",
		"tok_struct",
		"tok_typedef",
		"tok_union",
		"tok_xception",
		"';'",
		"tok_optional",
		"tok_required",
		"')'",
		"'{'",
		"tok_literal",
		"'>'",
		"tok_reference",
		"'['",
		"tok_dub_constant",
		"tok_void",
		"tok_xsd_attrs",
		"']'",
		"tok_oneway",
		"tok_xsd_nillable",
		"TypeAnnotations",
		"tok_cpp_include",
		"tok_include",
		"tok_namespace",
		"tok_xsd_optional",
		"':'",
		"CommaOrSemicolonOptional",
		"BaseType",
		"CaptureDocText",
		"ContainerType",
		"FieldType",
		"ListType",
		"MapType",
		"SetType",
		"SimpleBaseType",
		"SimpleContainerType",
		"'<'",
		"ConstList",
		"ConstMap",
		"ConstValue",
		"Field",
		"FieldList",
		"'='",
		"CppType",
		"tok_cpp_type",
		"'*'",
		"Const",
		"ConstListContents",
		"ConstMapContents",
		"Definition",
		"DefinitionList",
		"DestroyDocText",
		"Enum",
		"EnumDef",
		"EnumDefList",
		"EnumValue",
		"Extends",
		"FieldIdentifier",
		"FieldReference",
		"FieldRequiredness",
		"FieldValue",
		"FlagArgs",
		"Function",
		"FunctionList",
		"FunctionType",
		"Header",
		"HeaderList",
		"Include",
		"Oneway",
		"Program",
		"Senum",
		"SenumDef",
		"SenumDefList",
		"Service",
		"Struct",
		"StructHead",
		"Throws",
		"tok_extends",
		"tok_throws",
		"tok_xsd_all",
		"TypeAnnotation",
		"TypeAnnotationList",
		"TypeAnnotationValue",
		"Typedef",
		"TypeDefinition",
		"UnflagArgs",
		"Xception",
		"XsdAll",
		"XsdAttributes",
		"XsdNillable",
		"XsdOptional",
		"$default",
		"error",
		"tok_bool_constant",
		"tok_doctext",
	}

	yyTokenLiteralStrings = map[int]string{}

	yyReductions = map[int]struct{ xsym, components int }{
		0:   {0, 1},
		1:   {90, 2},
		2:   {49, 0},
		3:   {72, 0},
		4:   {87, 3},
		5:   {87, 0},
		6:   {86, 1},
		7:   {86, 4},
		8:   {86, 3},
		9:   {86, 2},
		10:  {88, 2},
		11:  {71, 3},
		12:  {71, 0},
		13:  {70, 1},
		14:  {70, 1},
		15:  {70, 1},
		16:  {105, 1},
		17:  {105, 1},
		18:  {105, 1},
		19:  {105, 1},
		20:  {105, 1},
		21:  {47, 1},
		22:  {47, 1},
		23:  {47, 0},
		24:  {104, 5},
		25:  {73, 6},
		26:  {75, 2},
		27:  {75, 0},
		28:  {74, 4},
		29:  {76, 3},
		30:  {76, 1},
		31:  {91, 6},
		32:  {93, 2},
		33:  {93, 0},
		34:  {92, 2},
		35:  {67, 6},
		36:  {60, 1},
		37:  {60, 1},
		38:  {60, 1},
		39:  {60, 1},
		40:  {60, 1},
		41:  {60, 1},
		42:  {58, 3},
		43:  {68, 3},
		44:  {68, 0},
		45:  {59, 3},
		46:  {69, 5},
		47:  {69, 0},
		48:  {96, 1},
		49:  {96, 1},
		50:  {95, 7},
		51:  {108, 1},
		52:  {108, 0},
		53:  {111, 1},
		54:  {111, 0},
		55:  {110, 1},
		56:  {110, 0},
		57:  {109, 4},
		58:  {109, 0},
		59:  {107, 6},
		60:  {94, 9},
		61:  {82, 0},
		62:  {106, 0},
		63:  {77, 2},
		64:  {77, 0},
		65:  {84, 2},
		66:  {84, 0},
		67:  {83, 10},
		68:  {89, 1},
		69:  {89, 0},
		70:  {97, 4},
		71:  {97, 0},
		72:  {62, 2},
		73:  {62, 0},
		74:  {61, 12},
		75:  {78, 2},
		76:  {78, 0},
		77:  {79, 1},
		78:  {79, 0},
		79:  {80, 1},
		80:  {80, 1},
		81:  {80, 0},
		82:  {81, 2},
		83:  {81, 0},
		84:  {85, 1},
		85:  {85, 1},
		86:  {51, 1},
		87:  {51, 1},
		88:  {51, 1},
		89:  {48, 2},
		90:  {55, 1},
		91:  {55, 1},
		92:  {55, 1},
		93:  {55, 1},
		94:  {55, 1},
		95:  {55, 1},
		96:  {55, 1},
		97:  {55, 1},
		98:  {55, 1},
		99:  {50, 2},
		100: {56, 1},
		101: {56, 1},
		102: {56, 1},
		103: {53, 7},
		104: {54, 5},
		105: {52, 5},
		106: {64, 2},
		107: {64, 0},
		108: {41, 3},
		109: {41, 0},
		110: {102, 2},
		111: {102, 0},
		112: {101, 3},
		113: {103, 2},
		114: {103, 0},
	}

	yyXErrors = map[yyXError]string{}

	yyParseTab = [199][]uint16{
		// 0
		{16: 110, 110, 110, 20: 110, 110, 110, 110, 110, 110, 42: 110, 110, 110, 87: 117, 90: 116},
		{16: 115},
		{16: 103, 103, 103, 20: 103, 103, 103, 103, 103, 103, 42: 112, 112, 112, 71: 118, 119},
		{16: 114, 113, 113, 20: 113, 113, 113, 113, 113, 113, 49: 143},
		{42: 123, 124, 122, 86: 120, 88: 121},
		// 5
		{16: 111, 111, 111, 20: 111, 111, 111, 111, 111, 111, 42: 111, 111, 111},
		{16: 109, 109, 109, 20: 109, 109, 109, 109, 109, 109, 42: 109, 109, 109},
		{127, 66: 128},
		{31: 126},
		{31: 125},
		// 10
		{16: 105, 105, 105, 20: 105, 105, 105, 105, 105, 105, 42: 105, 105, 105},
		{16: 106, 106, 106, 20: 106, 106, 106, 106, 106, 106, 42: 106, 106, 106},
		{130},
		{129},
		{16: 107, 107, 107, 20: 107, 107, 107, 107, 107, 107, 42: 107, 107, 107},
		// 15
		{15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 41: 131, 6, 6, 6},
		{16: 108, 108, 108, 20: 108, 108, 108, 108, 108, 108, 42: 108, 108, 108},
		{4, 29: 4, 102: 133},
		{136, 29: 134, 101: 135},
		{7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 16: 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 32: 7, 7, 36: 7, 39: 7, 42: 7, 7, 7},
		// 20
		{5, 29: 5},
		{1, 1, 26: 1, 29: 1, 63: 138, 103: 137},
		{92, 140, 26: 141, 29: 92, 47: 142},
		{31: 139},
		{2, 2, 26: 2, 29: 2},
		// 25
		{94, 2: 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 16: 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 27: 94, 94, 94, 94, 94, 34: 94, 94, 94, 38: 94, 94},
		{93, 2: 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 16: 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 27: 93, 93, 93, 93, 93, 34: 93, 93, 93, 38: 93, 93},
		{3, 29: 3},
		{17: 156, 154, 20: 155, 161, 157, 153, 158, 160, 67: 145, 70: 144, 73: 149, 91: 150, 94: 147, 151, 159, 104: 148, 146, 107: 152},
		{16: 104, 104, 104, 20: 104, 104, 104, 104, 104, 104},
		// 30
		{16: 102, 102, 102, 20: 102, 102, 102, 102, 102, 102},
		{16: 101, 101, 101, 20: 101, 101, 101, 101, 101, 101},
		{16: 100, 100, 100, 20: 100, 100, 100, 100, 100, 100},
		{16: 99, 99, 99, 20: 99, 99, 99, 99, 99, 99},
		{16: 98, 98, 98, 20: 98, 98, 98, 98, 98, 98},
		// 35
		{16: 97, 97, 97, 20: 97, 97, 97, 97, 97, 97},
		{16: 96, 96, 96, 20: 96, 96, 96, 96, 96, 96},
		{16: 95, 95, 95, 20: 95, 95, 95, 95, 95, 95},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 310, 193, 191, 192, 180, 190},
		{297},
		// 40
		{289},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 284, 193, 191, 192, 180, 190},
		{67},
		{66},
		{277},
		// 45
		{272},
		{162},
		{30: 51, 77: 163, 98: 164},
		{30: 166},
		{165},
		// 50
		{30: 52},
		{54, 2: 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 36: 54, 39: 54, 82: 167},
		{49, 2: 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 36: 49, 39: 49, 84: 168},
		{113, 2: 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 53, 36: 113, 39: 113, 49: 171, 83: 170, 106: 169},
		{14: 270},
		// 55
		{50, 2: 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 36: 50, 39: 50},
		{46, 2: 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 36: 46, 39: 173, 89: 172},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 36: 176, 48: 178, 50: 179, 175, 193, 191, 192, 180, 190, 85: 174},
		{47, 2: 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 36: 47},
		{215},
		// 60
		{31},
		{30},
		{29, 29, 32: 29, 29},
		{28, 28, 32: 28, 28},
		{27, 27, 32: 27, 27},
		// 65
		{6, 6, 15: 132, 32: 6, 6, 41: 214},
		{25, 25, 15: 25, 32: 25, 25},
		{24, 24, 15: 24, 32: 24, 24},
		{23, 23, 15: 23, 32: 23, 23},
		{22, 22, 15: 22, 32: 22, 22},
		// 70
		{21, 21, 15: 21, 32: 21, 21},
		{20, 20, 15: 20, 32: 20, 20},
		{19, 19, 15: 19, 32: 19, 19},
		{18, 18, 15: 18, 32: 18, 18},
		{17, 17, 15: 17, 32: 17, 17},
		// 75
		{6, 6, 15: 132, 32: 6, 6, 41: 213},
		{15, 15, 15: 15, 32: 15, 15},
		{14, 14, 15: 14, 32: 14, 14},
		{13, 13, 15: 13, 32: 13, 13},
		{57: 8, 64: 207, 201},
		// 80
		{57: 8, 64: 203, 201},
		{57: 197},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 198, 193, 191, 192, 180, 190},
		{32: 199},
		{8, 8, 15: 8, 32: 8, 8, 64: 200, 201},
		// 85
		{10, 10, 15: 10, 32: 10, 10},
		{31: 202},
		{9, 9, 15: 9, 32: 9, 9, 57: 9},
		{57: 204},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 205, 193, 191, 192, 180, 190},
		// 90
		{32: 206},
		{11, 11, 15: 11, 32: 11, 11},
		{57: 208},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 209, 193, 191, 192, 180, 190},
		{1: 210},
		// 95
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 211, 193, 191, 192, 180, 190},
		{32: 212},
		{12, 12, 15: 12, 32: 12, 12},
		{16, 16, 32: 16, 16},
		{26, 26, 32: 26, 26},
		// 100
		{15: 216},
		{42, 2: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 19: 42, 27: 42, 42, 42, 62: 217},
		{113, 2: 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 19: 113, 27: 113, 113, 218, 49: 220, 61: 219},
		{44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26: 44, 36: 44, 39: 44, 97: 263, 99: 264},
		{43, 2: 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 19: 43, 27: 43, 43, 43},
		// 105
		{39, 2: 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 19: 222, 27: 39, 39, 78: 221},
		{34, 2: 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 27: 226, 225, 80: 224},
		{46: 223},
		{40, 2: 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 27: 40, 40},
		{177, 2: 182, 184, 189, 186, 187, 188, 185, 196, 194, 195, 183, 181, 48: 178, 50: 179, 227, 193, 191, 192, 180, 190},
		// 110
		{36, 2: 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36},
		{35, 2: 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35},
		{37, 33: 229, 79: 228},
		{230},
		{38},
		// 115
		{32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 19: 32, 26: 32, 32, 32, 32, 37: 32, 40: 32, 45: 32, 63: 232, 81: 231},
		{61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 19: 61, 26: 61, 61, 61, 61, 37: 61, 40: 61, 45: 252, 111: 253},
		{236, 19: 233, 30: 240, 235, 34: 239, 234, 58: 237, 238, 241},
		{79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 34: 79, 79, 37: 79, 79, 40: 79, 45: 79, 79},
		{78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 34: 78, 78, 37: 78, 78, 40: 78, 45: 78, 78},
		// 120
		{77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 34: 77, 77, 37: 77, 77, 40: 77, 45: 77, 77},
		{76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 34: 76, 76, 37: 76, 76, 40: 76, 45: 76, 76},
		{75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 34: 75, 75, 37: 75, 75, 40: 75, 45: 75, 75},
		{74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 34: 74, 74, 37: 74, 74, 40: 74, 45: 74, 74},
		{71, 19: 71, 30: 71, 71, 34: 71, 71, 38: 71, 68: 248},
		// 125
		{68, 14: 68, 19: 68, 30: 68, 68, 34: 68, 68, 69: 242},
		{33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 19: 33, 26: 33, 33, 33, 33, 37: 33, 40: 33, 45: 33},
		{236, 14: 243, 19: 233, 30: 240, 235, 34: 239, 234, 58: 237, 238, 244},
		{70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 34: 70, 70, 37: 70, 70, 40: 70, 45: 70, 70},
		{46: 245},
		// 130
		{236, 19: 233, 30: 240, 235, 34: 239, 234, 58: 237, 238, 246},
		{92, 140, 14: 92, 19: 92, 26: 141, 30: 92, 92, 34: 92, 92, 47: 247},
		{69, 14: 69, 19: 69, 30: 69, 69, 34: 69, 69},
		{236, 19: 233, 30: 240, 235, 34: 239, 234, 38: 249, 58: 237, 238, 250},
		{73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 34: 73, 73, 37: 73, 73, 40: 73, 45: 73, 73},
		// 135
		{92, 140, 19: 92, 26: 141, 30: 92, 92, 34: 92, 92, 38: 92, 47: 251},
		{72, 19: 72, 30: 72, 72, 34: 72, 72, 38: 72},
		{62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 19: 62, 26: 62, 62, 62, 62, 37: 62, 40: 62},
		{59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 19: 59, 26: 59, 59, 59, 59, 37: 59, 40: 254, 110: 255},
		{60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 19: 60, 26: 60, 60, 60, 60, 37: 60},
		// 140
		{57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 19: 57, 26: 57, 57, 57, 57, 37: 256, 109: 257},
		{30: 260},
		{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 132, 19: 6, 26: 6, 6, 6, 6, 41: 258},
		{92, 140, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 19: 92, 26: 141, 92, 92, 92, 47: 259},
		{41, 2: 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 19: 41, 27: 41, 41, 41},
		// 145
		{42, 2: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 19: 42, 27: 42, 42, 62: 261},
		{113, 2: 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 262, 19: 113, 27: 113, 113, 49: 220, 61: 219},
		{58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 19: 58, 26: 58, 58, 58, 58},
		{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 132, 26: 6, 36: 6, 39: 6, 41: 268},
		{15: 265},
		// 150
		{42, 2: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 19: 42, 27: 42, 42, 42, 62: 266},
		{113, 2: 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 19: 113, 27: 113, 113, 267, 49: 220, 61: 219},
		{45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 26: 45, 36: 45, 39: 45},
		{92, 140, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 26: 141, 36: 92, 39: 92, 47: 269},
		{48, 2: 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 36: 48, 39: 48},
		// 155
		{15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 41: 271},
		{16: 55, 55, 55, 20: 55, 55, 55, 55, 55, 55},
		{30: 273},
		{42, 2: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 19: 42, 27: 42, 42, 62: 274},
		{113, 2: 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 275, 19: 113, 27: 113, 113, 49: 220, 61: 219},
		// 160
		{15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 41: 276},
		{16: 56, 56, 56, 20: 56, 56, 56, 56, 56, 56},
		{30: 63, 100: 279, 108: 278},
		{30: 280},
		{30: 64},
		// 165
		{42, 2: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 19: 42, 27: 42, 42, 62: 281},
		{113, 2: 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 282, 19: 113, 27: 113, 113, 49: 220, 61: 219},
		{15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 41: 283},
		{16: 65, 65, 65, 20: 65, 65, 65, 65, 65, 65},
		{285},
		// 170
		{63: 286},
		{236, 19: 233, 30: 240, 235, 34: 239, 234, 58: 237, 238, 287},
		{1: 140, 16: 92, 92, 92, 20: 92, 92, 92, 92, 92, 92, 141, 47: 288},
		{16: 80, 80, 80, 20: 80, 80, 80, 80, 80, 80},
		{30: 290},
		// 175
		{14: 82, 31: 82, 93: 291},
		{14: 292, 31: 294, 92: 293},
		{15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 41: 296},
		{14: 83, 31: 83},
		{1: 140, 14: 92, 26: 141, 31: 92, 47: 295},
		// 180
		{14: 81, 31: 81},
		{16: 84, 84, 84, 20: 84, 84, 84, 84, 84, 84},
		{30: 298},
		{88, 14: 88, 75: 299},
		{113, 14: 300, 49: 302, 74: 301},
		// 185
		{15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 41: 309},
		{89, 14: 89},
		{304, 76: 303},
		{6, 6, 14: 6, 132, 26: 6, 41: 307},
		{85, 85, 14: 85, 85, 26: 85, 63: 305},
		// 190
		{19: 306},
		{86, 86, 14: 86, 86, 26: 86},
		{92, 140, 14: 92, 26: 141, 47: 308},
		{87, 14: 87},
		{16: 90, 90, 90, 20: 90, 90, 90, 90, 90, 90},
		// 195
		{311},
		{1: 6, 15: 132, 6, 6, 6, 20: 6, 6, 6, 6, 6, 6, 6, 41: 312},
		{1: 140, 16: 92, 92, 92, 20: 92, 92, 92, 92, 92, 92, 141, 47: 313},
		{16: 91, 91, 91, 20: 91, 91, 91, 91, 91, 91},
	}
)

var yyDebug = 0

type yyLexer interface {
	Lex(lval *yySymType) int
	Error(s string)
}

type yyLexerEx interface {
	yyLexer
	Reduced(rule, state int, lval *yySymType) bool
}

func yySymName(c int) (s string) {
	x, ok := yyXLAT[c]
	if ok {
		return yySymNames[x]
	}

	if c < 0x7f {
		return __yyfmt__.Sprintf("%q", c)
	}

	return __yyfmt__.Sprintf("%d", c)
}

func yylex1(yylex yyLexer, lval *yySymType) (n int) {
	n = yylex.Lex(lval)
	fmt.Printf("[Token][%s/%d] id:%s\n", yySymName(n), n, lval.id)
	if n <= 0 {
		n = yyEofCode
	}
	if yyDebug >= 3 {
		__yyfmt__.Printf("\nlex %s(%#x %d), lval: %+v\n", yySymName(n), n, n, lval)
	}
	return n
}

func yyParse(yylex yyLexer) int {
	const yyError = 113

	yyEx, _ := yylex.(yyLexerEx)
	var yyn int
	var yylval yySymType
	var yyVAL yySymType
	yyS := make([]yySymType, 200)

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	yyerrok := func() {
		if yyDebug >= 2 {
			__yyfmt__.Printf("yyerrok()\n")
		}
		Errflag = 0
	}
	_ = yyerrok
	yystate := 0
	yychar := -1
	var yyxchar int
	var yyshift int
	yyp := -1
	goto yystack

ret0:
	return 0

ret1:
	return 1

yystack:
	/* put a state and value onto the stack */
	yyp++
	if yyp >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyS[yyp] = yyVAL
	yyS[yyp].yys = yystate

yynewstate:
	if yychar < 0 {
		yylval.yys = yystate
		yychar = yylex1(yylex, &yylval)
		var ok bool
		if yyxchar, ok = yyXLAT[yychar]; !ok {
			yyxchar = len(yySymNames) // > tab width
		}
	}
	if yyDebug >= 4 {
		var a []int
		for _, v := range yyS[:yyp+1] {
			a = append(a, v.yys)
		}
		__yyfmt__.Printf("state stack %v\n", a)
	}
	row := yyParseTab[yystate]
	yyn = 0
	if yyxchar < len(row) {
		if yyn = int(row[yyxchar]); yyn != 0 {
			yyn += yyTabOfs
		}
	}
	switch {
	case yyn > 0: // shift
		yychar = -1
		yyVAL = yylval
		yystate = yyn
		yyshift = yyn
		if yyDebug >= 2 {
			__yyfmt__.Printf("shift, and goto state %d\n", yystate)
		}
		if Errflag > 0 {
			Errflag--
		}
		goto yystack
	case yyn < 0: // reduce
	case yystate == 1: // accept
		if yyDebug >= 2 {
			__yyfmt__.Println("accept")
		}
		goto ret0
	}

	if yyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			if yyDebug >= 1 {
				__yyfmt__.Printf("no action for %s in state %d\n", yySymName(yychar), yystate)
			}
			msg, ok := yyXErrors[yyXError{yystate, yyxchar}]
			if !ok {
				msg, ok = yyXErrors[yyXError{yystate, -1}]
			}
			if !ok && yyshift != 0 {
				msg, ok = yyXErrors[yyXError{yyshift, yyxchar}]
			}
			if !ok {
				msg, ok = yyXErrors[yyXError{yyshift, -1}]
			}
			if yychar > 0 {
				ls := yyTokenLiteralStrings[yychar]
				if ls == "" {
					ls = yySymName(yychar)
				}
				if ls != "" {
					switch {
					case msg == "":
						msg = __yyfmt__.Sprintf("unexpected %s", ls)
					default:
						msg = __yyfmt__.Sprintf("unexpected %s, %s", ls, msg)
					}
				}
			}
			if msg == "" {
				msg = "syntax error"
			}
			yylex.Error(msg)
			Nerrs++
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for yyp >= 0 {
				row := yyParseTab[yyS[yyp].yys]
				if yyError < len(row) {
					yyn = int(row[yyError]) + yyTabOfs
					if yyn > 0 { // hit
						if yyDebug >= 2 {
							__yyfmt__.Printf("error recovery found error shift in state %d\n", yyS[yyp].yys)
						}
						yystate = yyn /* simulate a shift of "error" */
						goto yystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if yyDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
				}
				yyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			if yyDebug >= 2 {
				__yyfmt__.Printf("error recovery failed\n")
			}
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if yyDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", yySymName(yychar))
			}
			if yychar == yyEofCode {
				goto ret1
			}

			yychar = -1
			goto yynewstate /* try again in the same state */
		}
	}

	r := -yyn
	x0 := yyReductions[r]
	x, n := x0.xsym, x0.components
	yypt := yyp
	_ = yypt // guard against "declared and not used"

	yyp -= n
	if yyp+1 >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyVAL = yyS[yyp+1]

	/* consult goto table to find next state */
	exState := yystate
	yystate = int(yyParseTab[yyS[yyp].yys][x]) + yyTabOfs
	/* reduction by production r */
	if yyDebug >= 2 {
		__yyfmt__.Printf("reduce using rule %v (%s), and goto state %d\n", r, yySymNames[x], yystate)
	}

	switch r {
	case 1:
		{
			fmt.Println("Program -> Headers DefinitionList")
			if proto.G_program_doctext_candidate != "" && proto.G_program_doctext_status != proto.ALREADY_PROCESSED {
				proto.G_program.SetDoc(proto.G_program_doctext_candidate)
				proto.G_program_doctext_status = proto.ALREADY_PROCESSED
			}
			proto.Clear_doctext()
		}
	case 2:
		{
			if proto.G_parse_mode == proto.PROGRAM {
				yyVAL.dtext = proto.G_doctext
				proto.G_doctext = ""
			} else {
				yyVAL.dtext = ""
			}
		}
	case 3:
		{
			if proto.G_parse_mode == proto.PROGRAM {
				proto.Clear_doctext()
			}
		}
	case 4:
		{
			fmt.Println("HeaderList -> HeaderList Header")
		}
	case 5:
		{
			fmt.Println("HeaderList -> ")
		}
	case 6:
		{
			fmt.Println("Header -> Include")
		}
	case 7:
		{
			fmt.Printf("Header -> tok_namespace tok_identifier tok_identifier")
			proto.Declare_valid_program_doctext()
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.SetNamespaceWithLang(yyS[yypt-2].id, yyS[yypt-1].id)
			}
			if yyS[yypt-0].caftype != nil {
				proto.G_program.SetNamespaceAnnotations(yyS[yypt-2].id, yyS[yypt-0].caftype.GetAnnotations())
			}
		}
	case 8:
		{
			fmt.Println("Header -> tok_namespace * tok_identifier")
			proto.Declare_valid_program_doctext()
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.SetNamespaceWithLang("*", yyS[yypt-0].id)
			}
		}
	case 9:
		{
			fmt.Println("Header -> tok_cpp_include tok_literal")
			proto.Declare_valid_program_doctext()
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddCppInclude(yyS[yypt-0].id)
			}
		}
	case 10:
		{
			fmt.Println("Include -> tok_include tok_literal")
			proto.Declare_valid_program_doctext()
			if proto.G_parse_mode == proto.INCLUDES {
				path := proto.IncludeFile(yyS[yypt-0].id)
				if path != "" {
					proto.G_program.AddInclude(path, yyS[yypt-0].id)
				}
			}
		}
	case 11:
		{
			fmt.Println("DefintionList -> DefinitionList Definition")
			if yyS[yypt-1].dtext != "" && yyS[yypt-0].tdoc != nil {
				yyS[yypt-0].tdoc.SetDoc(yyS[yypt-1].dtext)
			}
		}
	case 12:
		{
			fmt.Println("DefinitionList -> ")
		}
	case 13:
		{
			fmt.Println("Definition -> Const")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddConst(yyS[yypt-0].tconst)
			}
			yyVAL.tdoc = proto.NewDoc(yyS[yypt-0].tconst.GetDoc())
		}
	case 14:
		{
			fmt.Println("Definition -> TypeDefinition")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_scope.AddType(yyS[yypt-0].caftype.GetName(), yyS[yypt-0].caftype)
				if proto.G_parent_scope != nil {
					proto.G_parent_scope.AddType(proto.G_parent_prefix+yyS[yypt-0].caftype.GetName(), yyS[yypt-0].caftype)
				}
				if !proto.G_program.IsUniqueTypename(yyS[yypt-0].caftype) {
					panic(fmt.Sprintf("Type \"%s\" is already defined.", yyS[yypt-0].caftype.GetName()))
				}
			}
			yyVAL.tdoc = proto.NewDoc(yyS[yypt-0].caftype.GetDoc())
		}
	case 15:
		{
			fmt.Println("Definition -> Service")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_scope.AddService(yyS[yypt-0].tservice.GetName(), yyS[yypt-0].tservice)
				if proto.G_parent_scope != nil {
					proto.G_parent_scope.AddService(proto.G_parent_prefix+yyS[yypt-0].tservice.GetName(), yyS[yypt-0].tservice)
				}
				proto.G_program.AddService(yyS[yypt-0].tservice)
				if !proto.G_program.IsUniqueTypename(yyS[yypt-0].tservice) {
					panic(fmt.Sprintf("Type \"%s\" is already defined.", yyS[yypt-0].tservice.GetName()))
				}
			}
			yyVAL.tdoc = proto.NewDoc(yyS[yypt-0].tservice.GetDoc())
		}
	case 16:
		{
			fmt.Println("TypeDefinition -> Typedef")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddTypedef(yyS[yypt-0].ttypedef)
				yyVAL.caftype = yyS[yypt-0].ttypedef
			}
		}
	case 17:
		{
			fmt.Println("TypeDefinition -> Enum")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddEnum(yyS[yypt-0].tenum)
				yyVAL.caftype = yyS[yypt-0].tenum
			}
		}
	case 18:
		{
			fmt.Println("TypeDefinition -> Senum")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddTypedef(yyS[yypt-0].ttypedef)
				yyVAL.caftype = yyS[yypt-0].ttypedef
			}
		}
	case 19:
		{
			fmt.Println("TypeDefinition -> Struct")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddStruct(yyS[yypt-0].tstruct)
				yyVAL.caftype = yyS[yypt-0].tstruct
			}
		}
	case 20:
		{
			fmt.Println("TypeDefinition -> Xception")
			if proto.G_parse_mode == proto.PROGRAM {
				proto.G_program.AddXception(yyS[yypt-0].tstruct)
				yyVAL.caftype = yyS[yypt-0].tstruct
			}
		}
	case 24:
		{
			fmt.Println("TypeDef -> tok_typedef FieldType tok_identifier")
			//proto.Validate_simple_identifier($3);
			td := proto.NewTypedef(proto.G_program, yyS[yypt-3].caftype, yyS[yypt-2].id, false)
			yyVAL.ttypedef = td
			if yyS[yypt-1].caftype != nil {
				yyVAL.ttypedef.SetAnnotations(yyS[yypt-1].caftype.GetAnnotations())
			}
		}
	case 25:
		{
			fmt.Println("Enum -> tok_enum tok_identifier { EnumDefList }")
			yyVAL.tenum = yyS[yypt-2].tenum
			//proto.Validate_simple_identifier( $2);
			yyVAL.tenum.SetName(yyS[yypt-4].id)
			if yyS[yypt-0].caftype != nil {
				yyVAL.tenum.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			}

			// make constants for all the enum values
			if proto.G_parse_mode == proto.PROGRAM {
				for _, v := range yyVAL.tenum.GetConstants() {
					const_name := yyVAL.tenum.GetName() + "." + v.GetName()
					const_val := proto.NewConstValue(v.GetValue())
					const_val.SetEnum(yyVAL.tenum)
					proto.G_scope.AddConstant(const_name, proto.NewConst(proto.G_type_i32, v.GetName(), const_val))
					if proto.G_parent_scope != nil {
						proto.G_parent_scope.AddConstant(proto.G_parent_prefix+const_name, proto.NewConst(proto.G_type_i32, v.GetName(), const_val))
					}
				}
			}
		}
	case 26:
		{
			fmt.Println("EnumDefList -> EnumDefList EnumDef")
			yyVAL.tenum = yyS[yypt-1].tenum
			yyVAL.tenum.Append(yyS[yypt-0].tenumv)
		}
	case 27:
		{
			fmt.Println("EnumDefList -> ")
			yyVAL.tenum = proto.NewEnum(proto.G_program)
			y_enum_val = -1
		}
	case 28:
		{
			fmt.Println("EnumDef -> EnumValue")
			yyVAL.tenumv = yyS[yypt-2].tenumv
			if yyS[yypt-3].dtext != "" {
				yyVAL.tenumv.SetDoc(yyS[yypt-3].dtext)
			}
			if yyS[yypt-1].caftype != nil {
				yyVAL.tenumv.SetAnnotations(yyS[yypt-1].caftype.GetAnnotations())
			}
		}
	case 29:
		{
			fmt.Println("EnumValue -> tok_identifier = tok_int_constant")
			y_enum_val = yyS[yypt-0].iconst
			yyVAL.tenumv = proto.NewEnumValue(yyS[yypt-2].id, y_enum_val)
		}
	case 30:
		{
			fmt.Println("EnumValue -> tok_identifier")
			//proto.Validate_simple_identifier( $1)
			y_enum_val++
			yyVAL.tenumv = proto.NewEnumValue(yyS[yypt-0].id, y_enum_val)
		}
	case 31:
		{
			fmt.Println("Senum -> tok_senum tok_identifier { SenumDefList }")
			//proto.Validate_simple_identifier( $2);
			yyVAL.ttypedef = proto.NewTypedef(proto.G_program, yyS[yypt-2].tbase, yyS[yypt-4].id, false)
			if yyS[yypt-0].caftype != nil {
				yyVAL.ttypedef.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			}
		}
	case 32:
		{
			fmt.Println("SenumDefList -> SenumDefList SenumDef")
			yyVAL.tbase = yyS[yypt-1].tbase
			yyVAL.tbase.AddStringEnumVal(yyS[yypt-0].id)
		}
	case 33:
		{
			fmt.Println("SenumDefList -> ")
			yyVAL.tbase = proto.NewBaseType("string", proto.TYPE_STRING)
			yyVAL.tbase.SetStringEnum(true)
		}
	case 34:
		{
			fmt.Println("SenumDef -> tok_literal")
			yyVAL.id = yyS[yypt-1].id
		}
	case 35:
		{
			fmt.Println("Const -> tok_const FieldType tok_identifier = ConstValue")
			if proto.G_parse_mode == proto.PROGRAM {
				//proto.Validate_simple_identifier($3)
				proto.G_scope.ResolveConstValue(yyS[yypt-1].tconstv, yyS[yypt-4].caftype)
				yyVAL.tconst = proto.NewConst(yyS[yypt-4].caftype, yyS[yypt-3].id, yyS[yypt-1].tconstv)
				//proto.Validate_const_type($$)

				proto.G_scope.AddConstant(yyS[yypt-3].id, yyVAL.tconst)
				if proto.G_parent_scope != nil {
					proto.G_parent_scope.AddConstant(proto.G_parent_prefix+yyS[yypt-3].id, yyVAL.tconst)
				}
			} else {
				yyVAL.tconst = nil
			}
		}
	case 36:
		{
			fmt.Println("ConstValue => tok_int_constant")
			yyVAL.tconstv = proto.NewConstValue(nil)
			yyVAL.tconstv.SetInteger(yyS[yypt-0].iconst)
		}
	case 37:
		{
			fmt.Println("ConstValue => tok_dub_constant")
			yyVAL.tconstv = proto.NewConstValue(nil)
			yyVAL.tconstv.SetDouble(yyS[yypt-0].dconst)
		}
	case 38:
		{
			fmt.Println("ConstValue => tok_literal")
			yyVAL.tconstv = proto.NewConstValue(yyS[yypt-0].id)
		}
	case 39:
		{
			fmt.Println("ConstValue => tok_identifier")
			yyVAL.tconstv = proto.NewConstValue(nil)
			yyVAL.tconstv.SetIdentifier(yyS[yypt-0].id)
		}
	case 40:
		{
			fmt.Println("ConstValue => ConstList")
			yyVAL.tconstv = yyS[yypt-0].tconstv
		}
	case 41:
		{
			fmt.Println("ConstValue => ConstMap")
			yyVAL.tconstv = yyS[yypt-0].tconstv
		}
	case 42:
		{
			fmt.Println("ConstList => [ ConstListContents ]")
			yyVAL.tconstv = yyS[yypt-1].tconstv
		}
	case 43:
		{
			fmt.Println("ConstListContents => ConstListContents ConstValue CommaOrSemicolonOptional")
			yyVAL.tconstv = yyS[yypt-2].tconstv
			yyVAL.tconstv.AddList(yyS[yypt-1].tconstv)
		}
	case 44:
		{
			fmt.Println("ConstListContents =>")
			yyVAL.tconstv = proto.NewConstValue(nil)
			yyVAL.tconstv.SetList()
		}
	case 45:
		{
			fmt.Println("ConstMap => { ConstMapContents }")
			yyVAL.tconstv = yyS[yypt-1].tconstv
		}
	case 46:
		{
			fmt.Println("ConstMapContents => ConstMapContents ConstValue CommaOrSemicolonOptional")
			yyVAL.tconstv = yyS[yypt-4].tconstv
			yyVAL.tconstv.AddMap(yyS[yypt-3].tconstv, yyS[yypt-1].tconstv)
		}
	case 47:
		{
			fmt.Println("ConstMapContents =>")
			yyVAL.tconstv = proto.NewConstValue(nil)
			yyVAL.tconstv.SetMap()
		}
	case 48:
		{
			yyVAL.iconst = struct_is_struct
		}
	case 49:
		{
			yyVAL.iconst = struct_is_union
		}
	case 50:
		{
			fmt.Println("Struct -> tok_struct tok_identifier { FieldList }")
			//proto.validate_simple_identifier( $2);
			yyS[yypt-2].tstruct.SetXsdAll(yyS[yypt-4].tbool)
			yyS[yypt-2].tstruct.SetUnion(yyS[yypt-6].iconst == struct_is_union)
			yyVAL.tstruct = yyS[yypt-2].tstruct
			yyVAL.tstruct.SetName(yyS[yypt-5].id)
			if yyS[yypt-0].caftype != nil {
				yyVAL.tstruct.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			}
		}
	case 51:
		{
			yyVAL.tbool = true
		}
	case 52:
		{
			yyVAL.tbool = false
		}
	case 53:
		{
			yyVAL.tbool = true
		}
	case 54:
		{
			yyVAL.tbool = false
		}
	case 55:
		{
			yyVAL.tbool = true
		}
	case 56:
		{
			yyVAL.tbool = false
		}
	case 57:
		{
			yyVAL.tstruct = yyS[yypt-1].tstruct
		}
	case 58:
		{
			yyVAL.tstruct = nil
		}
	case 59:
		{
			fmt.Println("Xception -> tok_xception tok_identifier { FieldList }")
			//proto.Validate_simple_identifier( $2)
			yyS[yypt-2].tstruct.SetName(yyS[yypt-4].id)
			yyS[yypt-2].tstruct.SetXception(true)
			yyVAL.tstruct = yyS[yypt-2].tstruct
			if yyS[yypt-0].caftype != nil {
				yyVAL.tstruct.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			}
		}
	case 60:
		{
			fmt.Println("Service -> tok_service tok_identifier { FunctionList }")
			//proto.Validate_simple_identifier( $2);
			yyVAL.tservice = yyS[yypt-3].tservice
			yyVAL.tservice.SetName(yyS[yypt-7].id)
			yyVAL.tservice.SetExtends(yyS[yypt-6].tservice)
			if yyS[yypt-0].caftype != nil {
				yyVAL.tservice.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			}
		}
	case 61:
		{
			G_arglist = 1
		}
	case 62:
		{
			G_arglist = 0
		}
	case 63:
		{
			fmt.Println("Extends -> tok_extends tok_identifier")
			yyVAL.tservice = nil
			if proto.G_parse_mode == proto.PROGRAM {
				yyVAL.tservice = proto.G_scope.GetService(yyS[yypt-0].id)
				if yyVAL.tservice == nil {
					panic(fmt.Sprintf("Service \"%s\" has not been defined.", yyS[yypt-0].id))
				}
			}
		}
	case 64:
		{
			yyVAL.tservice = nil
		}
	case 65:
		{
			fmt.Println("FunctionList -> FunctionList Function")
			yyVAL.tservice = yyS[yypt-1].tservice
			yyS[yypt-1].tservice.AddFunction(yyS[yypt-0].tfunction)
		}
	case 66:
		{
			fmt.Println("FunctionList -> ")
			yyVAL.tservice = proto.NewService(proto.G_program)
		}
	case 67:
		{
			//proto.Validate_simple_identifier( $4);
			yyS[yypt-4].tstruct.SetName(yyS[yypt-6].id + "_args")
			yyVAL.tfunction = proto.NewFunctionWithXception(yyS[yypt-7].caftype, yyS[yypt-6].id, yyS[yypt-4].tstruct, yyS[yypt-2].tstruct, yyS[yypt-8].tbool)
			if yyS[yypt-9].dtext != "" {
				yyVAL.tfunction.SetDoc(yyS[yypt-9].dtext)
			}
			if yyS[yypt-1].caftype != nil {
				yyVAL.tfunction.SetAnnotations(yyS[yypt-1].caftype.GetAnnotations())
			}
		}
	case 68:
		{
			yyVAL.tbool = true
		}
	case 69:
		{
			yyVAL.tbool = false
		}
	case 70:
		{
			fmt.Println("Throws -> tok_throws ( FieldList )")
			yyVAL.tstruct = yyS[yypt-1].tstruct
			if proto.G_parse_mode == proto.PROGRAM {
				panic("Throws clause may not contain non-exception types")
			}
		}
	case 71:
		{
			yyVAL.tstruct = proto.NewStruct(proto.G_program)
		}
	case 72:
		{
			fmt.Println("FieldList -> FieldList , Field")
			yyVAL.tstruct = yyS[yypt-1].tstruct
			if !(yyVAL.tstruct.Append(yyS[yypt-0].tfield)) {
				panic(fmt.Sprintf("\"%d: %s\" - field identifier/name has already been used", yyS[yypt-0].tfield.GetKey(), yyS[yypt-0].tfield.GetName()))
			}
		}
	case 73:
		{
			fmt.Printf("FieldList -> ")
			y_field_val = -1
			yyVAL.tstruct = proto.NewStruct(proto.G_program)
		}
	case 74:
		{
			fmt.Println("tok_int_constant : Field -> FieldType tok_identifier")
			if yyS[yypt-10].tfieldid.AutoAssigned {
				panic(fmt.Sprintf("No field key specified for %s, resulting protocol may have conflicts or not be backwards compatible!\n", yyS[yypt-6].id))
				if g_strict >= 192 {
					panic("Implicit field keys are deprecated and not allowed with -strict")
				}
			}
			//proto.Validate_simple_identifier($6);
			yyVAL.tfield = proto.NewField(yyS[yypt-8].caftype, yyS[yypt-6].id, int32(yyS[yypt-10].tfieldid.Value))
			yyVAL.tfield.SetReference(yyS[yypt-7].tbool)
			yyVAL.tfield.SetReq(yyS[yypt-9].ereq)
			if yyS[yypt-5].tconstv != nil {
				proto.G_scope.ResolveConstValue(yyS[yypt-5].tconstv, yyS[yypt-8].caftype)
				proto.Validate_field_value(yyVAL.tfield, yyS[yypt-5].tconstv)
				yyVAL.tfield.SetValue(yyS[yypt-5].tconstv)
			}
			yyVAL.tfield.SetXsdOptional(yyS[yypt-4].tbool)
			yyVAL.tfield.SetXsdNillable(yyS[yypt-3].tbool)
			if yyS[yypt-11].dtext != "" {
				yyVAL.tfield.SetDoc(yyS[yypt-11].dtext)
			}
			if yyS[yypt-2].tstruct != nil {
				yyVAL.tfield.SetXsdAttrs(yyS[yypt-2].tstruct)
			}
			if yyS[yypt-1].caftype != nil {
				yyVAL.tfield.SetAnnotations(yyS[yypt-1].caftype.GetAnnotations())
			}
		}
	case 75:
		{
			if yyS[yypt-1].iconst <= 0 {
				fmt.Printf("Nonpositive value (%d) not allowed as a field key.\n", yyS[yypt-1].iconst)
				yyVAL.tfieldid = proto.NewFieldId(65535, true)
			} else {
				yyVAL.tfieldid = proto.NewFieldId(int(yyS[yypt-1].iconst), false)
			}
			if (SHRT_MIN > yyVAL.tfieldid.Value) || (yyVAL.tfieldid.Value > SHRT_MAX) {
				fmt.Println("Field key (%d) exceeds allowed range (%d..%d).\n", yyVAL.tfieldid.Value, SHRT_MIN, SHRT_MAX)
			}
		}
	case 76:
		{
			yyVAL.tfieldid = proto.NewFieldId(65534, true)
			if (SHRT_MIN > yyVAL.tfieldid.Value) || (yyVAL.tfieldid.Value > SHRT_MAX) {
				fmt.Printf("Field key (%d) exceeds allowed range (%d..%d).\n", yyVAL.tfieldid.Value, SHRT_MIN, SHRT_MAX)
			}
		}
	case 77:
		{
			yyVAL.tbool = true
		}
	case 78:
		{
			yyVAL.tbool = false
		}
	case 79:
		{
			yyVAL.ereq = proto.T_REQUIRED
		}
	case 80:
		{
			if G_arglist > 0 {
				if proto.G_parse_mode == proto.PROGRAM {
					fmt.Println("optional keyword is ignored in argument lists.\n")
				}
				yyVAL.ereq = proto.T_OPT_IN_REQ_OUT
			} else {
				yyVAL.ereq = proto.T_OPTIONAL
			}
		}
	case 81:
		{
			yyVAL.ereq = proto.T_OPT_IN_REQ_OUT
		}
	case 82:
		{
			if proto.G_parse_mode == proto.PROGRAM {
				yyVAL.tconstv = yyS[yypt-0].tconstv
			} else {
				yyVAL.tconstv = nil
			}
		}
	case 83:
		{
			yyVAL.tconstv = nil
		}
	case 84:
		{
			fmt.Println("FunctionType -> FieldType")
			yyVAL.caftype = yyS[yypt-0].caftype
		}
	case 85:
		{
			fmt.Println("FunctionType -> tok_void")
			yyVAL.caftype = proto.G_type_void
		}
	case 86:
		{
			fmt.Println("FieldType -> tok_identifier")
			if proto.G_parse_mode == proto.INCLUDES {
				// Ignore identifiers in include mode
				yyVAL.caftype = nil
			} else {
				// Lookup the identifier in the current scope
				yyVAL.caftype = proto.G_scope.GetType(yyS[yypt-0].id)
				if yyVAL.caftype == nil {
					yyVAL.caftype = proto.NewTypedef(proto.G_program, nil, yyS[yypt-0].id, true)
				}
			}
		}
	case 87:
		{
			fmt.Println("FieldType -> BaseType")
			yyVAL.caftype = yyS[yypt-0].tbase
		}
	case 88:
		{
			fmt.Println("FieldType -> ContainerType")
			yyVAL.caftype = yyS[yypt-0].caftype
		}
	case 89:
		{
			fmt.Println("BaseType -> SimpleBaseType TypeAnnotations")
			if yyS[yypt-0].caftype != nil {
				yyVAL.tbase = proto.NewBaseType(yyS[yypt-1].tbase.GetName(), yyS[yypt-1].tbase.GetBase())
				yyVAL.tbase.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			} else {
				yyVAL.tbase = yyS[yypt-1].tbase
			}
		}
	case 90:
		{
			fmt.Println("BaseType -> tok_string")
			yyVAL.tbase = proto.G_type_string
		}
	case 91:
		{
			fmt.Println("BaseType -> tok_binary")
			yyVAL.tbase = proto.G_type_binary
		}
	case 92:
		{
			fmt.Println("BaseType -> tok_slist")
			yyVAL.tbase = proto.G_type_slist
		}
	case 93:
		{
			fmt.Println("BaseType -> tok_bool")
			yyVAL.tbase = proto.G_type_bool
		}
	case 94:
		{
			fmt.Println("BaseType -> tok_i8")
			yyVAL.tbase = proto.G_type_i8
		}
	case 95:
		{
			fmt.Println("BaseType -> tok_i16")
			yyVAL.tbase = proto.G_type_i16
		}
	case 96:
		{
			fmt.Println("BaseType -> tok_i32")
			yyVAL.tbase = proto.G_type_i32
		}
	case 97:
		{
			fmt.Println("BaseType -> tok_i64")
			yyVAL.tbase = proto.G_type_i64
		}
	case 98:
		{
			fmt.Println("BaseType -> tok_double")
			yyVAL.tbase = proto.G_type_double
		}
	case 99:
		{
			fmt.Println("ContainerType -> SimpleContainerType TypeAnnotations")
			yyVAL.caftype = yyS[yypt-1].caftype
			if yyS[yypt-0].caftype != nil {
				yyVAL.caftype.SetAnnotations(yyS[yypt-0].caftype.GetAnnotations())
			}
		}
	case 100:
		{
			fmt.Println("SimpleContainerType -> MapType")
			yyVAL.caftype = yyS[yypt-0].tmap
		}
	case 101:
		{
			fmt.Println("SimpleContainerType -> SetType")
			yyVAL.caftype = yyS[yypt-0].tset
		}
	case 102:
		{
			fmt.Println("SimpleContainerType -> ListType")
			yyVAL.caftype = yyS[yypt-0].tlist
		}
	case 103:
		{
			fmt.Println("MapType -> tok_map <FieldType, FieldType>")
			yyVAL.tmap = proto.NewMap(yyS[yypt-3].caftype, yyS[yypt-1].caftype)
			if yyS[yypt-5].id != "" {
				yyVAL.tmap.SetCppName(yyS[yypt-5].id)
			}
		}
	case 104:
		{
			fmt.Println("SetType -> tok_set<FieldType>")
			yyVAL.tset = proto.NewSet(yyS[yypt-1].caftype)
			if yyS[yypt-3].id != "" {
				yyVAL.tset.SetCppName(yyS[yypt-3].id)
			}
		}
	case 105:
		{
			fmt.Println("ListType -> tok_list<FieldType>")
			proto.Check_for_list_of_bytes(yyS[yypt-2].caftype)
			yyVAL.tlist = proto.NewList(yyS[yypt-2].caftype)
			if yyS[yypt-0].id != "" {
				yyVAL.tlist.SetCppName(yyS[yypt-0].id)
			}
		}
	case 106:
		{
			yyVAL.id = yyS[yypt-0].id
		}
	case 107:
		{
			yyVAL.id = ""
		}
	case 108:
		{
			fmt.Println("TypeAnnotations -> ( TypeAnnotationList )")
			yyVAL.caftype = yyS[yypt-1].caftype
		}
	case 109:
		{
			yyVAL.caftype = nil
		}
	case 110:
		{
			fmt.Println("TypeAnnotationList -> TypeAnnotationList , TypeAnnotation")
			yyVAL.caftype = yyS[yypt-1].caftype
			yyVAL.caftype.SetAnnotation(yyS[yypt-0].tannot.Key, yyS[yypt-0].tannot.Value)
		}
	case 111:
		{
			yyVAL.caftype = proto.NewStruct(proto.G_program)
		}
	case 112:
		{
			fmt.Printf("TypeAnnotation -> TypeAnnotationValue")
			yyVAL.tannot = proto.NewAnnotation(yyS[yypt-2].id, yyS[yypt-1].id)
		}
	case 113:
		{
			fmt.Printf("TypeAnnotationValue -> = tok_literal")
			yyVAL.id = yyS[yypt-0].id
		}
	case 114:
		{
			fmt.Printf("TypeAnnotationValue ->")
			yyVAL.id = "1"
		}

	}

	if yyEx != nil && yyEx.Reduced(r, exState, &yyVAL) {
		return -1
	}
	goto yystack /* stack new state and value */
}
